These notes are based on "Stack Computers: The New Wave" Table 3.1.

DS - data stack
RS - return stack
IO - input/output
IR - instruction register
PC - program counter (instruction pointer)
MAR - memory access register
PM - program memory


!       n1 addr --          Store n1 at location addr in PM
@       addr    -- n1       Fetch the value at location addr in PM as n1
+       n1 n2   -- n3       Add n1 and n2, giving n3
-       n1 n2   -- n3       Subtract n2 rom n1, giving n3
and     n1 n2   -- n3       Perform a bitwise AND on n1 and n2, giving n3
or      n1 n2   -- n3       Perform a bitwise OR on n1 and n2, giving n3
xor     n1 n2   -- n3       Perform a bitwise XOR on n1 and n2, giving n3
>r      n1      --          Push n1 on to the return stack
r>              -- n1       Pop RS, push to TOS
dup     n1      -- n1 n1    Duplicate n1 to TOS
drop    n1      --          Drop n1 from the stack
over    n1 n2   -- n1 n2 n1 Duplicate the second stack element to TOS
swap    n1 n2   -- n2 n1    Swap the order of the top two elements
[if]    n1      --          If n1 == 0, branch to address in next cell
[call]          --          Perform a subroutine call to address in next cell
[exit]          --          Perform a subroutine return
[lit]           -- n1       Push the value in the next cell to DS


!       n1 addr --          TOS -> MAR, DS -> PM, POP_DS, DS -> TOS
@       addr    -- n1       TOS -> MAR, PM -> TOS
+       n1 n2   -- n3       
-       n1 n2   -- n3       
and     n1 n2   -- n3       
or      n1 n2   -- n3       
xor     n1 n2   -- n3       
>r      n1      --          TOS -> RS, DS -> TOS
r>              -- n1       
dup     n1      -- n1 n1    
drop    n1      --          
over    n1 n2   -- n1 n2 n1 
swap    n1 n2   -- n2 n1    
[if]    n1      --          
[call]          --          
[exit]          --          
[lit]           -- n1       

