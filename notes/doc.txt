


\  __  __                        _____                                        
\ |  \/  |                      |  __ \                                       
\ | \  / | __ _  ___ _ __ ___   | |__) | __ ___   ___ ___  ___ ___  ___  _ __ 
\ | |\/| |/ _` |/ __| '__/ _ \  |  ___/ '__/ _ \ / __/ _ \/ __/ __|/ _ \| '__|
\ | |  | | (_| | (__| | | (_) | | |   | | | (_) | (_|  __/\__ \__ \ (_) | |   
\ |_|  |_|\__,_|\___|_|  \___/  |_|   |_|  \___/ \___\___||___/___/\___/|_|   
\
\                                                          version: 2023-02-13
\   by Charles Edward Pax











\                   +-----+     |||        +-----+
\                   | DS  |<===>|||        | TOS |<=+
\                   +-----+     | |====+   +-----+  |
\                               |D|    |      |     |
\                   +-----+     |A|  __V__  __V__   |
\                   | RS  |<===>|T|  \ A  \/  B /   |
\                   +-----+     |A|   \  ALU   /    |
\                               | |    \______/     |
\                               |B|        |        |
\                   +-----+     |U|    +-------+    |
\                   | PC  |<===>|S|<===|shifter|====+
\                   +-----+     | |    +-------+
\                               |||
\                   +-----+     |||     +-----+
\                   | MAR |<====|||<===>| IR  |
\                   +-----+     |||     + - - +
\                      ||       |||     | CL  |
\                   +-----+     |||     +-----+
\                   | PM  |<===>|||     +-----+
\                   +-----+     |||<===>| IO  |
\                               |||     +-----+



















\ <line 64>  MacroProcessor v2023-02-13                                          <page 1>
\ FRONT MATTER --------------------------------------------------------------------------

\ Line #    Name
\ ------    ---------------------------------
\           Front Matter
\           Introduction
\           Architectual Overview
\           Change Log

\ List of figures
\ ---------------
\           Figure abd: Architecture block diagram

\ List of tables
\ --------------
















































\ <line 128>  MacroProcessor v2023-02-13  FRONT MATTER                           <page 2>
\ INTRODUCTION --------------------------------------------------------------------------

\ The Macro Processor is a microprocessor with an unconventional design
\ goal: understandability. An individual human should be able to visually
\ observe the integrated circuit (IC) with an optical microscope and
\ verify the layout and function of the circuit.

\ This document is intended to be both documentation of the system and
\ the software supporting the system. If you have the documentation,
\ you have the code.

\ Lines that start with a '(' character are comments and are not processed
\ by Forth interperters. Empty lines are not processed by Forth. All other
\ lines are meant to be interperted by the Forth interperter.

\ This document is designed to be printed sixty-four lines per page. See
\ Appendix: Printing for more information including a bash script to
\ automate printing.

\ This processor is designed to run Forth. It may run other languages
\ with a bit of effort, but none will be made here.

\ This document contains a Forth language assembler. There are a set of
\ Forth words defined here that can be used to generate binary code that
\ can be run on the MacroProcessor.






































\ <line 192, page 3>    MacroProcessor v2023-02-13
\ ARCHITECTUAL OVERVIEW ----------------------------------------------------------------\

\ The overall design of the Central Processin Unit (CPU) is based on the
\ "canonical stack machine" as described in "Stack Machines: The New Wave"
\ by Philip Koopman.


\ Figure abd: Architecture block diagram

\                   +-----+     |||        +-----+
\                   | DS  |<===>| |        | TOS |<=+
\                   +-----+     |D|====+   +-----+  |
\                               |A|    |      |     |
\                   +-----+     |T|  __V__  __V__   |
\                   | RS  |<===>|A|  \ A  \/  B /   |
\                   +-----+     |||   \  ALU   /    |
\                               |B|    \______/     |
\                               |U|        |        |
\                   +-----+     |S|    +-------+    |
\                   | PC  |<===>| |<===|shifter|====+
\                   +-----+     |||    +-------+
\                               |||
\                   +-----+     |||     +-----+
\                   | MAR |<====|||<===>| IR  |
\                   +-----+     |||     + - - +
\                      ||       |||     | CL  |
\                   +-----+     |||     +-----+
\                   | PM  |<===>|||     +-----+
\                   +-----+     |||<===>| IO  |
\                               |||     +-----+

\ The CPU contains the following items.

\ DS - Data Stack                 TOS - Top of Stack
\ RS - Return Stack               ALU - Arithmetic Logic Unit
\ IO - Input/Output               PC - Program Counter
\ IR - Instructions Register      MAR - Memory Access Register
\ CL - Control Logic              PM - Program Memory

\ Modules DS, RS, IO, PC, and PM are able to accept input from the
\ data bus or output to the data bus, as indicated by the double
\ arrows '<===>'. Multiplexors ensure only one module may
\ output a signal to the data bus and only one module may input
\ a signal from the data bus.

\ Modules IR and MAR are able to accept input from the data bus,
\ but are not able to putout their contents to the data bus.

\ ALU always accepts input from TOS via input B and is able
\ to accept input from the data bus via input A. ALU is can
\ output to either TOS or the data bus.

\ TOS always outputs to ALU input B. TOS always accepts input
\ from ALU. TOS can recieve data from the data bus by passing
\ the signal through ALU.








\ <line 256, page 4>    MacroProcessor v2023-02-13
\ MODULE FEATURES ----------------------------------------------------------------------\

\ Data Stack:
\       >DS ( DS intput enable )
\       DS> ( DS output enable )
\       DS++ ( increment DS )
\       DS-- ( decriment DS )

\ Return Stack:
\       >RS ( RS input enable )
\       RS> ( RS output enable )
\       RS++ ( increment RS )
\       RS-- ( decriment RS )

\ Instruction Register:
\       >IR ( IR input enable )

\ Control Logic:

\ Program Counter:
\       >PC ( PC input enable )
\       PC> ( PC output enable )
\       PC++ ( increment PC )
\       PC-- (decriment PC )           / TODO: why?

\ Arithmetic Logic Unit
\ ---------------------
\ When ~>>ALU (ALU_OP = 0), ALU input A = 0x0

\ "ALU> ,ALU_AND" will always output zero to the bus
\ "ALU_AND" makes TOS zero
































\ <line 320, page 5>    MacroProcessor v2023-02-13
\ INSTRUCTION SET ARCHITECTURE (ISA) ---------------------------------------------------\

\ Instructions are created by doing a bitwise OR of multiple words
\ from the definitions below.


\       xxxx             Bits 15-12 - source enable
\           xxxx         Bits 11-08 - Destination enable
\               xxxx     Bits 7-4 - ALU operation select
\                   xxx  Bits 3-1 - Stack increment select
\                      x Bit 0 - Memory operation









\ ALU OP codes to add (these have flags)
\ -------------------
\ ADD^ add
\ ADC^ add with carry
\ CMP^ compare
\ SBB^ subtract with borrow

\ The CPU should have flags for instructions. Forth will have
\ flags placed on the stack.


































\ <line 384, page 6>    MacroProcessor v2023-02-13
\ Figure ISA: Instruction Set Architecture

\ Word    Binary OP Code      Stack     OP Code Description
\ ------- -----------------   --------- -------------------------------------------------
: NOP     %0000000000000000 ; (  -- n ) ( No Operation. )
\         %0000------------ ; (  --  )  ( See NOP. Bits 15-12 - Source enable )
: DS>     %0001000000000000 ; (  -- n ) ( Data Stack output )
: RS>     %0010000000000000 ; (  -- n ) ( Return Stack output )
: PC>     %0011000000000000 ; (  -- n ) ( Program Counter outout )
: PM>     %0100000000000000 ; (  -- n ) ( Program Memory output )
: IO>     %0101000000000000 ; (  -- n ) ( Input/Output output )
:         %0110------------ ; (  --  )  (  )
: ALU>    %0111000000000000 ; (  -- n ) ( ALU to bus output )
\         %1000------------ ; (  -- n ) (  )
\         %1001------------ ; (  -- n ) (  )
\         %1010------------ ; (  -- n ) (  )
\         %1011------------ ; (  -- n ) (  )
\         %1100------------ ; (  -- n ) (  )
\         %1101------------ ; (  -- n ) (  )
\         %1110------------ ; (  -- n ) (  )
\         %1111------------ ; (  -- n ) (  )
\         %----0000-------- ; (  --  )  ( See NOP. Bits 11-08 - Destination enable )
: >DS     %0000000100000000 ; (  -- n ) ( into Data Stack )
: >RS     %0000001000000000 ; (  -- n ) ( into Return Stack )
: >PC     %0000001100000000 ; (  -- n ) ( into Program Counter )
: >PM     %0000010000000000 ; (  -- n ) ( into Program Memory )
: >IO     %0000010100000000 ; (  -- n ) ( into Input/Output )
:         %----0110-------- ; (  --  )  (  )
: >ALU    %0000011100000000 ; (  -- n ) ( into Arithmetic Logic Unit )
: >MAR    %0000100000000000 ; (  -- n ) ( into Memory Access Register )
: >IR     %0000100100000000 ; (  -- n ) ( into Instruction Register )
\         %----1010-------- ; (  -- n ) (  )
\         %----1011-------- ; (  -- n ) (  )
\         %----1100-------- ; (  -- n ) (  )
\         %----1101-------- ; (  -- n ) (  )
\         %----1110-------- ; (  -- n ) (  )
\         %----1111-------- ; (  -- n ) (  )
\         %--------0000---- ; (  --  )  ( See NOP. Bits 7-4 - ALU operation select )
: ALU_ADD %0000000000010000 ; (  -- n ) ( ALU ADD enable )
: ALU_SUB %0000000000100000 ; (  -- n ) ( ALU SUB enable ) \ necessary? 2s compliment
: ALU_AND %0000000000110000 ; (  -- n ) ( ALU AND enable )
: ALU_OR  %0000000001000000 ; (  -- n ) ( ALU OR enable )
: ALU_XOR %0000000001010000 ; (  -- n ) ( ALU XOR enable )
: ALU_<<  %0000000001100000 ; (  -- n ) (  )
: ALU_>>  %0000000001110000 ; (  -- n ) (  )
\ ALU_TOS %0000000010000000 ; (  -- n ) ( Sets ALU for bus passthrough of TOS )
\         %--------1001---- ; (  -- n ) (  )
\         %--------1010---- ; (  -- n ) (  )
\         %--------1011---- ; (  -- n ) (  )
\         %--------1101---- ; (  -- n ) (  )
\         %--------1110---- ; (  -- n ) (  )
\         %--------1111---- ; (  -- n ) (  )
\         %------------000- ; (  --  )  ( See NOP. Bits 3-1 - Stack increment select )
: DS++    %0000000000000010 ; (  -- n ) (  )
: RS++    %0000000000000100 ; (  -- n ) (  )
: PC++    %0000000000000110 ; (  -- n ) (  )
\         %------------100- ; (  -- n ) (  )
: DS--    %0000000000001010 ; (  -- n ) (  )               \ Is this necessary?
: RS--    %0000000000001100 ; (  -- n ) (  )
\         %------------111- ; (  -- n ) (  )
\         %---------------0 ; (  --  )  ( See NOP. Bit 0 - Memory operation )
: MOP     %0000000000000001 ; (  --  )  ( memory access microinscruction enable )

\ <line 448>  MacroProcessor v2023-02-13  INSTRUCTION SET ARCHICETURE            <page 7>
\ COMBINATIONAL INSTRUCTION WORDS ------------------------------------------------------\

\ Given the nature of the instruction format, the base control words
\ can be combined into instructions by using a bitwise OR
\ operations.

\ We will define another set of words identical to the list of
\ control words, but with the addition of a bitwise OR operation.

: ,NOP  NOP  OR ; (  -- n ) ( No Operation )
: ,DS>  DS>  OR ; (  -- n ) ( Data Stack output )
: ,RS>  RS>  OR ; (  -- n ) ( Return Stack output )
: ,PC>  PC>  OR ; (  -- n ) ( Program Counter outout )
: ,PM>  PM>  OR ; (  -- n ) ( Program Memory output )
: ,IO>  IO>  OR ; (  -- n ) ( Input/Output output )
: ,ALU> ALU> OR ; (  -- n ) (  )
: ,>DS  >DS  OR ; (  -- n ) ( into Data Stack )
: ,>RS  >RS  OR ; (  -- n ) ( into Return Stack )
: ,>PC  >PC  OR ; (  -- n ) ( into Program Counter )
: ,>PM  >PM  OR ; (  -- n ) ( into Program Memory )
: ,>IO  >IO  OR ; (  -- n ) ( into Input/Output )
: ,>TOS >TOS OR ; (  -- n ) ( into Top Of Stack )
: ,>ALU >ALU OR ; (  -- n ) ( into Arithmetic Logic Unit )
: ,>MAR >MAR OR ; (  -- n ) ( into Memory Access Register )
: ,>IR  >IR  OR ; (  -- n ) ( into Instruction Register )
: ,ALU_ADD  ALU_ADD  OR ; (  -- n ) ( ALU ADD enable )
: ,ALU_SUB  ALU_SUB  OR ; (  -- n ) ( ALU SUB enable )
: ,ALU_AND  ALU_AND  OR ; (  -- n ) ( ALU AND enable )
: ,ALU_OR   ALU_OR   OR ; (  -- n ) ( ALU OR enable )
: ,ALU_XOR  ALU_XOR  OR ; (  -- n ) ( ALU XOR enable )
: ,DS++ DS++   OR ; (  -- n ) ( increment RS )
: ,DS-- DS--   OR ; (  -- n ) ( decremetn RS )
: ,RS++ RS++   OR ; (  -- n ) ( increment RS )
: ,RS-- RS--   OR ; (  -- n ) ( decremetn RS )
; ,ALU_TOS OR ; (  -- n ) ( TOS passthrough )

\ This notation results in clear instructions without requiring
\ an assembler. Take, for example, copying the contents of PC into
\ RS and incrimenting RS.

\              PC> ,>RS ,RS+

\ Step 1. PC> places onto the stack  %0011000000000000
\ Step 2. ,>RS places onto the stack %0000001000000000 
\         and performs a bitwise OR,
\         leaving onto the stack     %0011001000000000
\ Step 3. ,RS+ places onto the stack %0000000000000001
\         and performs a bitwise OR,
\         leaving on the stack       %0011001000000001

\ TODO: implement RS++

\ Not every combination makes sense even though it is possible.
\ For example PC> ,>RS ,ADD will copy the contents of PS to RS
\ and will enable the ALU ADD function, but nothing will be
\ added because the ALU is not active.







\ <line 512, page 8>    MacroProcessor v2023-02-13
\ INSTRUCTION CYCLE --------------------------------------------------------------------\

\ Microinstructions
\ ---------------------
\ Step 000:  PC> ,>MAR
\ Step 001:  PM> ,>IR ,PC++
\ Step 010:  CL = IR[ PM> ,>xx ,MEMORY_OP ]
\ (if ~MEMORY_OP, then reset step count)
\ Step 011:  PC> ,>MAR                           \ PC++ here?
\ Step 100:  PM> ,>xx ,PC++                      \ >xx and other bits from step 010
\ reset step count

\ TODO: LSB indicates if this is a memory operation
\       0 - Reset the count
\       1 - Read the next cell to destination

\ TODO: can steps 010 and 011 be combined?
\ TODO: TODO: include ALU glag affects?
\ TODO: Write a section that describes the instruction cycle
\ TODO: Do I always want to increment PC? What about when JMP? If I load an address
\       into PD, I probably want the value to remain in PC until it is used.



\ Figure timing: Timing chart description of the instruction cycle.

\ exe - execution
\ CL - control logic
\         __________________________________________________________________________
\ RESET _/       
\            _______         _______         _______         _______         _______
\  CLK  ____/       \_______/       \_______/       \_______/       \_______/     
\       ____         _______         _______         _______         _______
\ ~CLK      \_______/       \_______/       \_______/       \_______/       \_______

\ Step: 000           001              010             011           100
\   CL: PC> ,>MAR   | PM> ,>IR ,PC++|  CL=IR[]      |  PC> ,>MAR    | PM> ,>xx ,PC++

\           |  PC> ,>MAR    | PM> ,>IR ,PC++|  CL=IR[]      |  PC> ,>MAR    | PM> ,>xx ,PC++
\           .               .               .               .               .
\           .               .               .               .               .
\   PC: 0   .               .1              .               .               .
\  MAR: ?   .0              .               .               .1              .
\   IR: ?   .               .PM[0]          .               .               .

\ TODO: Write an explaination of the instrucion cycle timing chart
\       Maybe a diagram of the MEM_OP branching.


\ This definitions is for illustrations
\ : PUSH ( n OPCODE --  )  ( copy the next cell of PM to the stack )
\       TOS> >DS ,DS++
\       PM> ,>TOS ,MEMORY_OP
\ TODO: make this correct









\ <line 576, page 9>    MacroProcessor v2023-02-13
\ RESET --------------------------------------------------------------------------------\

\ - After RESET MAR is set to all zeroes, which will select the first
\   cell of PM.

\ STATUS AND FLAGS ---------------------------------------------------------------------\
\ - Instead of having a flags register, try to make a design where at
\   the end of each subroutine a status cell is pushed onto the stack.
\   This could simplify the hardware at the expense of software
\   complication.
\ - Only some words would need to do this. It whould be obvious to the
\   programmer which words. Perhaps only ALU or conditional words.
\ - I can make an RTOS or other small OS. Tasks communicate via
\   the stack.
\   Each task consumes TOS and upon exit, pushes to TOS.

























\ INTERRUPTS ---------------------------------------------------------------------------\






















\ <line 640, page 10>    MacroProcessor v2023-02-13
\ *****************
\ ** Other Notes **
\ *****************

\ - Should I include zero register? Would this be done by the ALU?
\ - How should the ALU and TOS be configured? See the Canonical Stack
\   Machine and the RTX2000 as examples. Several processors from
\   "Stack Machine" use the same configuration at the RTS2000.
\ - In the final book, include a branch diagram for each word in the
\   non-ANS Forth dictionary using graphviz dot.
\   * Both DS> and INC_DS can execute at the same time or individually,
\     one cell or two cells respectively. We can keep them as two
\     separate words or combine them into one hand-coded POP. There
\     is a tradeoff between speed and memory.
\   * Two adjacent singleton branches could ind8icate a possible
\     new word. Maybe we can find some interesting properties.
\ - I could potentially make the data register a set of sixteen
\   bidirectional shift registers in parallel. Possibly make them
\   circular/linear selectable.
\ - Is it possible to use materials in the semiconductor manufacturing
\   process that will allow each layer to fluress when exposed to a
\   specific frequency of light? This would be great to visual
\   inspection of the device.
\ - Add a binary tree word diagram to each word in the dictionary.
\   This can be done using graphviz dot, but text would be better, so
\   the diagram can be in this document. Can I write my definitions such
\   that the reader has the same level of understanding? 
\ - How do I deal with ALU flags/status?
\ - Is anything memory-mapped?
\ - See Forth v6 at mosaic-industries.com
\ - The memory has two bytes per cell. Use address bits 14-0 as
\   memory bits 15-1, with bit zero = 0. Use address bit 15 to switch
\   to another memory unit or control structure.
\ - How does CALL, RETURN, EXIT, etc. work?
\ - How does a memory unit work?
\ - Memory Map
\     - address bit 0 is always 0
\ - Look into JonesForth
\ - "Look at "the bitcoin bitfield (interpreter.h, line 43) in ROM chip"
\ - Look at xxd for text to binary
\ - SmithForth, a very nice layout for simple Forth interpreter. See
\   "SmithForth Workings" on youtube
\ - See retroforth.org, camelforth, collapse OS, midrocore on github (forth2020,
\   MicroForth
\ -  Read "Moving Forth" by Brad Rodriguez
\ - See github.com/miniforth. Fits on a boot sector

















\ <line 704>  MacroProcessor v2023-02-13 OTHER NOTES                 <page 11>































































\ <line 768>  MacroProcessor v2023-02-13 OTHER NOTES                            <page 12>
\ HARDWARE DIAGRAM ---------------------------------------------------------------------\
\ Figure dia: Full diagram

\  16-bit                               16-bit
\   |||  +-+    +-----------------+      |||             +-------+
\   |||--|L|--->| Data Stack      |<====>|||             | Top   |
\   |||  |O|    |   DS>           |      |||======\\     | of    |<==========\\
\   |||  |G|    |   >DS           |      |||      ||     | Stack |           ||
\   |||  |I|    |   DS++          |      |||      ||     |       |<-\        ||
\   | |  |C|    |   DS--          |      | |      ||     +-------+  |        ||
\   |C|  +-+    +-----------------+      |D|      ||        ||      |        ||
\   |O|                                  |A|      ||        ||      |        ||
\   |N|  +-+    +-----------------+      |T|  ____\/___  ___\/____  |        ||
\   |T|--|L|--->| Return Stack    |<====>|A|  \    A   \/   B    /  |        ||
\   |R|  |O|    |   RS>           |      |||   \                /  +-+  |||  ||
\   |O|  |G|    |   >RS           |      |B|    \     ALU      /<--|L|--|||  ||
\   |L|  |I|    |   RS++          |      |U|     \            /    |O|  |||  ||
\   |||  |C|    |   RS--          |      |S|      \          /     |G|  |||  ||
\   |B|  +-+    +-----------------+      | |       \________/      |I|  |||  ||
\   |U|                                  |||           ||    /-----|C|  |||  ||
\   |S|  +-+    +-----------------+      |||           ||    v     +-+  |||  ||
\   | |--|L|--->| Program Counter |<====>|||     +-----\/-----+         |||  ||
\   |||  |O|    |   PC>           |      |||<====|  Shifter   |==============//
\   |||  |G|    |   >PC           |      |||     +------------+         |||
\   |||  |I|    |   PC+           |      |||                            |||  ALU_ADD
\   |||  |C|    |                 |      |||                            |||  ALU_SUB
\   |||  +-+    +-----------------+      |||     +-------------+        |||  ALU_AND
\   |||                                  |||====>| Instruction |        |||  ALU_OR
\   |||  +-+    +-----------------+      |||     | Register    |        |||  ALU_XOR
\   |||--|L|--->| Memory Access   |<=====|||     |   >IR       |        |||  ALU_>>
\   |||  |O|    | Register        |      |||     |             |        |||  ALU_<<
\   |||  |G|    |   >MAR          |      |||     + - - - - - - +        |||  ALU_TOS
\   |||  |I|    |                 |      |||     | Step        |=======>|||
\   |||  |C|    |                 |      |||     | Counter     |        |||
\   |||  +-+    +-----------------+      |||     +-------------+        |||
\   |||                 ||               |||                            |||
\   |||                 ||               |||                            |||
\   |||  +-+    +-------\/--------+      |||     +-------------+   +-+  |||
\   |||--|L|--->| Program Memory  |<====>|||<===>| Input/Output|<--|L|--|||
\   |||  |O|    |   PM>           |      |||     | Output      |   |O|  |||
\   |||  |G|    |   >PM           |              |   IO>       |   |G|  |||
\   |||  |I|    |                 |              |   >IO       |   |I|  |||
\   |||  |C|    |                 |              |             |   |C|  |||
\   |||  +-+    +-----------------+              +-------------+   +-+  |||
\   |||                                                                 |||
\   \\\-----------------------------------------------------------------///
\    \\-----------------------------------------------------------------//
\     \-----------------------------------------------------------------/
\      Control Bus                      Step Counter
\      ------------------------         ------------
\      15-12 source enable              000 PC> ,>MAR
\      11-08 destination enable         001 PM> ,>IR ,PC++
\      07-04 ALU_OP                     010 CL = IR[]
\      03-01 stack increment                (if not MEM_OP, reset counter
\         00 MEM_OP                     011 OC> ,>MAR
\                                       100 PM> ,>XX ,PC++
\                                       101 reset step counter

\ TODO: Add a section describing the ALU
\       ALU_ADD ALU_OR ALU_XOR ALU_ROTATE ALU_COMPARE ALU_COMPLEMENT
\       FLAGS: A-B=0, ZERO=1
\       A-B<0, NEGATIVE=1
\       ALU overflow bit, OVERFLOW=1
\ <line 832>  MacroProcessor v2023-02-13 HARDWARE DIAGRAM                       <page 13>
\ DICTIONARY DEFINITIONS ---------------------------------------------------------------\

: CALLI ( Call function located as address located in next cell in PM )
        PC> ,>ALU ,ALU_ADD ,MOP
        0x04
        ALU> ,>RS ,RS++
        JMPI
        0xXX
        RETURN
        

: JMP ( addr --  )  ( Jump to address on top of stack )
        SWAP
        DS> ,>PC ,DS--

: JMPI (  --  ) ( Jump to address stored in next cell of PM )
        PM> ,>PC ,MOP

: RET (  --  ) ( RETURN )
        RS> ,>PC ,RS--


: SWAP ( n1 n2 -- n2 n1 ) ( swap the top to stack elements )
        ALU> ,>RS ,RS++ ,ALU_TOS
        DS> ,>ALU ,ALU_TOS
        RS> ,>DS ,RS--

\ These notes are based on "Stack Computers: The New Wave" Table 3.1.

\ !       n1 addr --          Store n1 at location addr in PM
\ @       addr    -- n1       Fetch the value at location addr in PM as n1
\ +       n1 n2   -- n3       Add n1 and n2, giving n3
\ -       n1 n2   -- n3       Subtract n2 rom n1, giving n3
\ and     n1 n2   -- n3       Perform a bitwise AND on n1 and n2, giving n3
\ or      n1 n2   -- n3       Perform a bitwise OR on n1 and n2, giving n3
\ xor     n1 n2   -- n3       Perform a bitwise XOR on n1 and n2, giving n3
\ >r      n1      --          Push n1 on to the return stack
\ r>              -- n1       Pop RS, push to TOS
\ dup     n1      -- n1 n1    Duplicate n1 to TOS
\ drop    n1      --          Drop n1 from the stack
\ over    n1 n2   -- n1 n2 n1 Duplicate the second stack element to TOS
\ swap    n1 n2   -- n2 n1    Swap the order of the top two elements
\ [if]    n1      --          If n1 == 0, branch to address in next cell
\ [call]          --          Perform a subroutine call to address in next cell
\ [exit]          --          Perform a subroutine return
\ [lit]           -- n1       Push the value in the next cell to DS

















\ <line 896>  MacroProcessor v2023-02-13 DICTIONARY DEFINITIONS                 <page 14>
\ SCRIPTS ------------------------------------------------------------------------------\

\ CODE: print.sh - Print this document

\ #!/bin/bash

\ # check if an argument was passed
\ if [ $# -eq 0 ]; then
\   echo "Error: No argument provided"
\   exit 1
\ fi

\ # store the argument as a variable
\ file=$1

\ # set the default number of lines to 20
\ lines=64

\ # check if a second argument was passed
\ if [ $# -eq 2 ]; then
\   lines=$2
\ fi

\ # check if the argument is a file
\ if [ ! -f "$file" ]; then
\   echo "Error: First argument is not a file"
\   exit 1
\ fi

\ # add line numbers to the file
\ nl -b a $file > $file.numbered

\ # split the file into groups of the specified number of lines and print each group
\ split -l $lines $file.numbered -d -a 4 print_
\ for i in print_*; do
  lp -o cpi=16 -o lpi=7 -o page-bottom=70 -o page-left=50 -o page-right=60 -o page-top=60 $i
\ done

\ # delete the temporary files
\ rm print_*
\ rm $file.numbered

\ # exit the script with a success status code
\ exit 0

\ TODO: write a script to generate table of contents
\ TODO: write a script to generate a lis of figures/ tables
\ TODO: write a script to generate the page footer















\ <line 960>  MacroProcessor v2023-02-13  SCRIPTS                               <page 15>
\ DOCUMENT CONVENTIONS -----------------------------------------------------------------\

\ TABLES AND FIGURES -------------------------------------------------------------------\

\ - Each table/figure is preceeded and followed by two empty lines

\ <line 1024>  MacroProcessor v2023-02-13  TABLES AND FIGURES                   <page 16>

\ --------------------------------------------------------------------------------------\
\ <line 1088>  MacroProcessor v2023-02-13                                       <page 17>

\ --------------------------------------------------------------------------------------\
\ <line 1024>  MacroProcessor v2023-02-13                                       <page 18>









