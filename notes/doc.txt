


(  __  __                        _____                                        
( |  \/  |                      |  __ \                                       
( | \  / | __ _  ___ _ __ ___   | |__) | __ ___   ___ ___  ___ ___  ___  _ __ 
( | |\/| |/ _` |/ __| '__/ _ \  |  ___/ '__/ _ \ / __/ _ \/ __/ __|/ _ \| '__|
( | |  | | (_| | (__| | | (_) | | |   | | | (_) | (_|  __/\__ \__ \ (_) | |   
( |_|  |_|\__,_|\___|_|  \___/  |_|   |_|  \___/ \___\___||___/___/\___/|_|   
      
(                by Charles Edward Pax





(                +---------+     |||          +-----+
(                | DS      |<===>|||          | TOS |<=\
(                +---------+     |D|======\   +-----+  |
(                                |A|      |      |     |
(                +---------+     |T|    __V__  __V__   |
(                | RS      |<===>|A|    \    \/    /   |
(                +---------+     |||     \  ALU   /    |
(                                |B|      \______/     |
(                +---------+     |U|          |        |
(                | IO      |<===>|S|<=========*========/
(                +---------+     |||
(                                |||     +----+
(                +---------+     |||<===>| PC |
(                | IR      |<====|||     +----+
(                +---------+     |||
(                    ||          |||     +-----+
(                +---------+     |||====>| MAR |
(                | Control |     |||     +-----+
(                | Logic   |     |||       ||
(                +---------+     |||     +----+
(                                |||<===>| PM |
(                                |||     +----+












( TODO: insert environment-specific code. See SUBLEQ book line 1

( TODO: insert notes for printing this document
( TODO: print blocks of lines in groups of n=50 or
(       print based on a ( PAGE tag and break at n=50 lines

( TODO: insert cover page

( TODO: 

( Macroprocessor
( =============
( - This is my notes for the macroprocessor
( - Comments begin with '('. There must be a space after. 

( CPU Architecture Diagram
( ========================
( - Stack machine

( +---------+     |||          +-----+
( | DS      |<===>|||          | TOS |<=\
( +---------+     |D|======\   +-----+  |
(                 |A|      |      |     |
( +---------+     |T|    __V__  __V__   |
( | RS      |<===>|A|    \    \/    /   |
( +---------+     |||     \  ALU   /    |
(                 |B|      \______/     |
( +---------+     |U|          |        |
( | IO      |<===>|S|<=========*========/
( +---------+     |||
(                 |||     +----+
( +---------+     |||<===>| PC |
( | IR      |<====|||     +----+
( +---------+     |||
(     ||          |||     +-----+
( +---------+     |||====>| MAR |
( | Control |     |||     +-----+
( | Logic   |     |||       ||
( +---------+     |||     +----+
(                 |||<===>| PM |
(                 |||     +----+


( TODO: consider combining PC and RS. Maybe DS RS and PC/RS can be
(       identical.
( TODO: Does Control Logic do the incrimentation and decrementitation?
(       or is that performed withing PC? Perhaps any repeated logic 
(       can be in the Control Logic.


( Subunit descriptions
( ====================
( RESET sets the initial state of the machine and affects 
( all(?) components.


( Data Stack:
(       >DS ( DS intput enable )
(       DS> ( DS output enable )
(       DS+ ( increment DS )
(       DS- ( decriment DS )

( Return Stack:
(       >RS ( RS input enable )
(       RS> ( RS output enable )
(       RS+ ( increment RS )
(       RS- ( decriment RS )

( Instruction Register:
(       >IR ( IR output enable )

( Control Logic:

( Program Counter:
(       >PC ( PC input enable )
(       PC> ( PC output enable )
(       PC+ ( increment PC )
(       PC- (decriment PC )






















( Fundemental Words
( =================
( - The words defined in this section are written in pure machine code
(   the Macroprocessor and do not rely on any other Forth words.
( - Some instructions are encoded via multiplexors to prevent multiple
(   sources driving the data bus or the ALU. Otherwise, instructions
(   are left unencoded.

(       %---------------- binary number (e.g. %100 = 4, %101=5, etc.)
(       |111------------- 15-13 select bus driver, 3-bit encoding
(       |654
(       ||  1111  ------- 12-07 destination output enable, unencoded
(       ||  321098
(       ||  |     7654321 06-00 unassigned bits
(       ||  |     |
: NOP  %0000000000000000 ; (  --  )  ( No Operation )
: DS>  %0010000000000000 ; (  -- n ) ( Data Stack output )
: RS>  %0100000000000000 ; (  -- n ) ( Return Stack output )
: IO>  %0110000000000000 ; (  -- n ) ( Input/Output output )
: PC>  %1000000000000000 ; (  -- n ) ( Program Counter outout )
: PM>  %1010000000000000 ; (  -- n ) ( >PM does not exist )
: TOS> %1100000000000000 ; (  -- n ) ( Top Of Stack output )
( :    %1110000000000000 ; (  -- n ) ( un defined )
: >DS  %0001000000000000 ; (  -- n ) ( Data Stack input )
: >RS  %0000100000000000 ; (  -- n ) ( Return Stack input )
: >IR  %0000010000000000 ; (  -- n ) ( IR> does not exist )
: >PC  %0000001000000000 ; (  -- n ) ( Program Counter input )
: >MAR %0000000100000000 ; (  -- n ) ( MR> does not exist )
: >TOS %0000000010000000 ; (  -- n ) ( Top Of Stack input )
: ADD  %0000000000000000 ; (  -- n )  \
: SUB  %0000000000000000 ; (  -- n )  |
: AND  %0000000000000000 ; (  -- n )  |
: OR   %0000000000000000 ; (  -- n )   > ALU instructions
: XOR  %0000000000000000 ; (  -- n )  |
: <<r  %0000000000000000 ; (  -- n )  |
: r>>  %0000000000000000 ; (  -- n )  /

( TODO: Would a NOP be better defined as whatever +PC is? That would
(       make 0x0 available as an instruction! Maybe 0x0 is +PC.
( TODO: Any source that can drive the data bus should be on a driver
(       and that driver connected to a mux to ensure only a single  
(       device drives the data bus at any one time. That may as well
(       be encoded in three bits for seven possible driving source 
(       options plus one NOP.
( TODO: Determine the rules for combining fundemental words. I'm sure
(       there are some that cannot be combined.

( TODO: Encode any ALU operations that are mutually exclusive.



( Combinational Instruction Words
( ===============================
( - These words can be used to combined additional operations with
(   the fundemental words above.
( - example:
(   DS> >TOS +DSI

( TODO: Figure out a way to combine words like DS> and >TOS. Maybe
(       ;; can be placed at the end of a line to OR two items
(       together. This would require each line to provide two
(       elements on the stack. This may or may not be possible, 
(       but the solution will likely become obvious as I continue
(       development.
(       : ;; OR ( n n -- n )

( A comman at the front of a word indicates that this does a
( bitwise OR with the top element of the stack.
: ,ADD ADD OR ( n -- n )
: ,SUB SUB OR ( n -- n )
: ,DS+ DS+ OR ( n -- n ) ( DS incriment )
: ,DS- DS- OR ( n -- n ) ( DS decriment )
: ,RSI RS+ OR ( n -- n ) ( Return Stack Incriment )
: ,RSD RS- OR ( n -- n ) ( Return Stack Decriment )
: ,>DS >DS OR
: ,DS> DS> OR
: ,>RS >DS OR
: ,RS> RS> OR






















( Instruction Representation
( ==========================

( TODO: How often does +IPI get executed? Should +IPI be built into the
(       hardware to happen automatically? Should it be a toggle? Then
(       we must poll, remember, or assert the state; complicated.

(   | DS  | RS  | IO  |  IR===CL  | ALU  | TOS  | IP  |  MAR===PM  |
(   +-----+-----+-----+-----+-----+------+------+-----+------+-----+
( 0 |     |     |     |     |  X  |      |      |     |      |     | +NOP ,PC+
(   +-----+-----+-----+-----+-----+------+------+-----+------+-----+
( 1 |     |     |     |     |  X  |      |      | PC> | >MAR |     | IP> ,>MAR ,PC+
(   +-----+-----+-----+-----+-----+------+------+-----+------+-----+
( 2 |     |     |     | >IR |  X  |      |      |     |      | PM> | PM> ,>IR ,PC+
(   +-----+-----+-----+-----+-----+------+------+-----+------+-----+
( 3 |     |     |     |     |  X  |      |      |     |      |     | 
(   +-----+-----+-----+-----+-----+------+------+-----+------+-----+
( 4 |     |     |     |     |  X  |      |      |     |      |     |

( TODO: Find a good wat to represent the state of the machine.
(       Horizontally would be best.





























( RESET
( =====
( - After RESET MAR is set to all zeroes, which will select the first
(   cell of PM.

( Status and Flags
( ================
( - Instead of having a flags register, try to make a design where at
(   the end of each subroutine a status cell is pushed onto the stack.
(   This could simplify the hardware at the expense of software
(   complication.
( - Only some words would need to do this. It whould be obvious to the
(   programmer which words. Perhaps only ALU or conditional words.
( - I can make an RTOS or other small OS. Tasks communicate via
(   the stack.
(   Each task consumes TOS and upon exit, pushes to TOS.


( Interrupts
( ==========
( TODO 


( Other Notes
( ===========
( - Should I include zero register? Would this be done by the ALU?
( - How should the ALU and TOS be configured? See the Canonical Stack
(   Machine and the RTX2000 as examples. Several processors from
(   "Stack Machine" use the same configuration at the RTS2000.
( - In the final book, include a branch diagram for each word in the
(   non-ANS Forth dictionary using graphviz dot.
(   * Both DS> and INC_DS can execute at the same time or individually,
(     one cell or two cells respectively. We can keep them as two
(     separate words or combine them into one hand-coded POP. There
(     is a tradeoff between speed and memory.
(   * Two adjacent singleton branches could ind8icate a possible
(     new word. Maybe we can find some interesting properties.
( - I could potentially make the data register a set of sixteen
(   bidirectional shift registers in parallel. Possibly make them
(   circular/linear selectable.
( - Is it possible to use materials in the semiconductor manufacturing
(   process that will allow each layer to fluress when exposed to a
(   specific frequency of light? This would be great to visual
(   inspection of the device.
( - Add a binary tree word diagra to each word in the dictionary.
(   This can be done using graphviz dot, but text would be better, so
(   the diagram can be in this document. Can I write my definitions such
(   that the reader has the same level of understanding? 


These notes are based on "Stack Computers: The New Wave" Table 3.1.

DS - data stack
RS - return stack
IO - input/output
IR - instruction register
PC - program counter (instruction pointer)
MAR - memory access register
PM - program memory

!       n1 addr --          Store n1 at location addr in PM
@       addr    -- n1       Fetch the value at location addr in PM as n1
+       n1 n2   -- n3       Add n1 and n2, giving n3
-       n1 n2   -- n3       Subtract n2 rom n1, giving n3
and     n1 n2   -- n3       Perform a bitwise AND on n1 and n2, giving n3
or      n1 n2   -- n3       Perform a bitwise OR on n1 and n2, giving n3
xor     n1 n2   -- n3       Perform a bitwise XOR on n1 and n2, giving n3
>r      n1      --          Push n1 on to the return stack
r>              -- n1       Pop RS, push to TOS
dup     n1      -- n1 n1    Duplicate n1 to TOS
drop    n1      --          Drop n1 from the stack
over    n1 n2   -- n1 n2 n1 Duplicate the second stack element to TOS
swap    n1 n2   -- n2 n1    Swap the order of the top two elements
[if]    n1      --          If n1 == 0, branch to address in next cell
[call]          --          Perform a subroutine call to address in next cell
[exit]          --          Perform a subroutine return
[lit]           -- n1       Push the value in the next cell to DS

!       n1 addr --          TOS -> MAR, DS -> PM, POP_DS, DS -> TOS
@       addr    -- n1       TOS -> MAR, PM -> TOS
+       n1 n2   -- n3       
-       n1 n2   -- n3       
and     n1 n2   -- n3       
or      n1 n2   -- n3       
xor     n1 n2   -- n3       
>r      n1      --          TOS -> RS, DS -> TOS
r>              -- n1       
dup     n1      -- n1 n1    
drop    n1      --          
over    n1 n2   -- n1 n2 n1 
swap    n1 n2   -- n2 n1    
[if]    n1      --          
[call]          --          
[exit]          --          
[lit]           -- n1       

